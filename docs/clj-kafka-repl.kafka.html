<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>clj-kafka-repl.kafka documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">clj-kafka-repl</span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clj-kafka-repl</span></div></div></li><li class="depth-2 branch"><a href="clj-kafka-repl.channel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>channel</span></div></a></li><li class="depth-2 current"><a href="clj-kafka-repl.kafka.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>kafka</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="clj-kafka-repl.kafka.html#var-consume"><div class="inner"><span>consume</span></div></a></li><li class="depth-1"><a href="clj-kafka-repl.kafka.html#var-get-earliest-offsets"><div class="inner"><span>get-earliest-offsets</span></div></a></li><li class="depth-1"><a href="clj-kafka-repl.kafka.html#var-get-group-offset"><div class="inner"><span>get-group-offset</span></div></a></li><li class="depth-1"><a href="clj-kafka-repl.kafka.html#var-get-group-offsets"><div class="inner"><span>get-group-offsets</span></div></a></li><li class="depth-1"><a href="clj-kafka-repl.kafka.html#var-get-lag"><div class="inner"><span>get-lag</span></div></a></li><li class="depth-1"><a href="clj-kafka-repl.kafka.html#var-get-latest-offsets"><div class="inner"><span>get-latest-offsets</span></div></a></li><li class="depth-1"><a href="clj-kafka-repl.kafka.html#var-get-message"><div class="inner"><span>get-message</span></div></a></li><li class="depth-1"><a href="clj-kafka-repl.kafka.html#var-get-topic-partitions"><div class="inner"><span>get-topic-partitions</span></div></a></li><li class="depth-1"><a href="clj-kafka-repl.kafka.html#var-produce"><div class="inner"><span>produce</span></div></a></li><li class="depth-1"><a href="clj-kafka-repl.kafka.html#var-sample"><div class="inner"><span>sample</span></div></a></li><li class="depth-1"><a href="clj-kafka-repl.kafka.html#var-set-group-offsets.21"><div class="inner"><span>set-group-offsets!</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">clj-kafka-repl.kafka</h1><div class="doc"><div class="markdown"><p>Functions for consuming, producing and reading metadata from kafka.</p></div></div><div class="public anchor" id="var-consume"><h3>consume</h3><div class="usage"><code>(consume topic &amp; {:keys [partition offset partition-offsets key-deserializer value-deserializer limit filter-fn], :or {partition nil, offset :end, partition-offsets nil, key-deserializer (default-key-deserializer), value-deserializer (default-value-deserializer), limit nil, filter-fn (constantly true)}})</code></div><div class="doc"><div class="markdown"><p>Opens a consumer over the specified topic and returns a ::ch/tracked-channel which is a wrapper over a core.async channel.</p>
<p>The channel will stay open indefinitely unless either: a) the channel is explicitly closed using ch/close! or b) the specified message limit is reached.</p>
<p>Examples of pulling data from channels:</p>
<ul>
  <li>
  <p>Pop the next message (if any) from the channel:  (ch/poll! tc)</p></li>
  <li>
  <p>Stream channel to file:  (ch/to-file tc “/workspace/temp/your-file”)</p></li>
  <li>
  <p>Stream channel to stdout:  (ch/to-stdout tc)</p></li>
  <li>
  <p>Close and dump current contents of channel to stdout:  (ch/dump! tc)</p></li>
</ul>
<p>And then close the channel with: (ch/close! tc)</p>
<table>
  <thead>
    <tr>
      <th align="left">key </th>
      <th align="left">default </th>
      <th align="left">description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="left"><code>:partition</code> </td>
      <td align="left"><code>nil</code> </td>
      <td align="left">Limit consumption to a specific partition. </td>
    </tr>
    <tr>
      <td align="left"><code>:offset</code> </td>
      <td align="left"><code>:end</code> </td>
      <td align="left">Start consuming from the specified offset. Valid values: <code>:start</code>, <code>:end</code>, numeric offset, timestamp (as date/time string) </td>
    </tr>
    <tr>
      <td align="left"><code>:partition-offsets</code> </td>
      <td align="left"><code>nil</code> </td>
      <td align="left">Vector of partition+offset vector pairs that represent a by-partition representation of offsets to start consuming from. </td>
    </tr>
    <tr>
      <td align="left"><code>:key-deserializer</code> </td>
      <td align="left"><code>nil</code> </td>
      <td align="left">Deserializer to use to deserialize the message key. Will use a string deserializer if not specified. </td>
    </tr>
    <tr>
      <td align="left"><code>:value-deserializer</code></td>
      <td align="left"><code>nil</code> </td>
      <td align="left">Deserializer to use to deserialize the message value. Will use an edn deserializer if not specified. </td>
    </tr>
    <tr>
      <td align="left"><code>:limit</code> </td>
      <td align="left"><code>nil</code> </td>
      <td align="left">The maximum number of messages to pull back either into the stream or the results vector (depending on stream mode). </td>
    </tr>
    <tr>
      <td align="left"><code>:filter-fn</code> </td>
      <td align="left"><code>nil</code> </td>
      <td align="left"><code>filter</code> function to apply to the incoming :kafka-message(s). Can be a string, in which case a filter on the message value containing that string is implied. </td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-get-earliest-offsets"><h3>get-earliest-offsets</h3><div class="usage"><code>(get-earliest-offsets topic &amp; {:keys [partitions], :or {partitions nil}})</code></div><div class="doc"><div class="markdown"><p>Gets a vector of vectors representing the mapping of partition-&gt;earliest-offset for the partitions of the given topic.</p>
<table>
  <thead>
    <tr>
      <th align="left">key </th>
      <th align="left">default </th>
      <th align="left">description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="left"><code>:partitions</code> </td>
      <td align="left"><code>nil</code> </td>
      <td align="left">Limit the results to the specified collection of partitions. </td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-get-group-offset"><h3>get-group-offset</h3><div class="usage"><code>(get-group-offset topic group partition)</code></div><div class="doc"><div class="markdown"><p>Gets the offset of the given consumer group on the given topic/partition.</p></div></div></div><div class="public anchor" id="var-get-group-offsets"><h3>get-group-offsets</h3><div class="usage"><code>(get-group-offsets topic group)</code></div><div class="doc"><div class="markdown"><p>Gets the offsets on all partitions of the given topic for the specified consumer group.</p></div></div></div><div class="public anchor" id="var-get-lag"><h3>get-lag</h3><div class="usage"><code>(get-lag topic group &amp; {:keys [verbose?], :or {verbose? true}})</code></div><div class="doc"><div class="markdown"><p>Gets the topic lag for the given consumer group.</p>
<table>
  <thead>
    <tr>
      <th align="left">key </th>
      <th align="left">default </th>
      <th align="left">description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="left"><code>:verbose?</code> </td>
      <td align="left"><code>false</code> </td>
      <td align="left">If <code>true</code>, will include by-partition breakdown. </td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-get-latest-offsets"><h3>get-latest-offsets</h3><div class="usage"><code>(get-latest-offsets topic &amp; {:keys [partitions], :or {partitions nil}})</code></div><div class="doc"><div class="markdown"><p>Gets a vector of vectors representing the mapping of partition-&gt;latest-offset for the partitions of the given topic.</p>
<table>
  <thead>
    <tr>
      <th align="left">key </th>
      <th align="left">default </th>
      <th align="left">description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="left"><code>:partitions</code> </td>
      <td align="left"><code>nil</code> </td>
      <td align="left">Limit the results to the specified collection of partitions. </td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-get-message"><h3>get-message</h3><div class="usage"><code>(get-message topic offset &amp; {:keys [deserializer partition], :or {deserializer nil, partition nil}})</code></div><div class="doc"><div class="markdown"><p>Gets the message at the specified offset on the given topic (if any).</p>
<table>
  <thead>
    <tr>
      <th align="left">key </th>
      <th align="left">default </th>
      <th align="left">description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="left"><code>:partition</code> </td>
      <td align="left"><code>nil</code> </td>
      <td align="left">Limit consumption to a specific partition. </td>
    </tr>
    <tr>
      <td align="left"><code>:deserializer</code> </td>
      <td align="left"><code>nil</code> </td>
      <td align="left">Deserializer to use to deserialize the message value. Will create an avro-deserializer if not specified (or nippy-deserializer if topic name contains the word ‘internal’). </td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-get-topic-partitions"><h3>get-topic-partitions</h3><div class="usage"><code>(get-topic-partitions topic)</code></div><div class="doc"><div class="markdown"><p>Gets the vector of partitions available for the given topic.</p></div></div></div><div class="public anchor" id="var-produce"><h3>produce</h3><div class="usage"><code>(produce topic &amp; {:keys [key-serializer value-serializer], :or {key-serializer (default-key-serializer), value-serializer (default-value-serializer)}})</code></div><div class="doc"><div class="markdown"><p>Produce messages to the specified topic.</p>
<table>
  <thead>
    <tr>
      <th align="left">key </th>
      <th align="left">default </th>
      <th align="left">description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="left"><code>:key-serializer</code> </td>
      <td align="left"><code>nil</code> </td>
      <td align="left">Serializer to use to serialize the message key. Will use a string deserializer if not specified. </td>
    </tr>
    <tr>
      <td align="left"><code>:value-serializer</code></td>
      <td align="left"><code>nil</code> </td>
      <td align="left">Serializer to use to serialize the message value. Will use an edn serializer if not specified. </td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-sample"><h3>sample</h3><div class="usage"><code>(sample topic &amp; opts)</code></div><div class="doc"><div class="markdown"><p>Convenience function around kafka/consume to just sample a message from the topic.</p></div></div></div><div class="public anchor" id="var-set-group-offsets.21"><h3>set-group-offsets!</h3><div class="usage"><code>(set-group-offsets! topic group partition-offsets &amp; {:keys [consumer], :or {consumer nil}})</code></div><div class="doc"><div class="markdown"><p>Sets the offsets for the specified group on the specified topic to the offsets given in the passed sequence of partition-&gt;offset pairs. The offset in each pair can be one of several types:</p>
<ul>
  <li>A natural integer - an absolute offset.</li>
  <li>A negative integer - an offset relative to the current offset (i.e. deduct from the current offset)</li>
  <li>:start - seek to start.</li>
  <li>:end - seek to end.</li>
  <li>date-time string - set offset to that which was current at the given time.</li>
</ul></div></div></div></div></body></html>